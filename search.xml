<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ECMAScript数据类型与值</title>
      <link href="2020/12/12/ECMAScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC/"/>
      <url>2020/12/12/ECMAScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><strong>以下内容基于Draft ECMA-262 / December 7, 2020阶段的标准以及网上搜集整理的资料。</strong></p><h2 id="ECMAScript类型"><a href="#ECMAScript类型" class="headerlink" title="ECMAScript类型"></a>ECMAScript类型</h2><p>ECMAScript数据类型包括：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code>、<code>Symbol</code>、<code>BigInt</code>、<code>Object</code>。</p><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a><strong>Undefined</strong> 类型</h3><p><code>Undefined</code>类型只有一个值，就是<strong>undefined</strong>，任何一个没有赋过值的变量的默认值都是 <strong>undefined</strong>。<strong>undefined</strong>是一个全局的变量，早期的JavaScript版本可以为它重新赋值，现在只能在函数里面局部地去定义Undefined的值：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><p>一般用<code>void 0;</code>来产生undefined，因为void运算符是个关键字，void后面不管跟什么，都会变成undefined这个值，所以在语法上最简洁地得到undefined的值的方法就是使用这个void关键字来进行一次运算。</p><p>undefined不是一个关键字。</p><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a><strong>Null</strong> 类型</h3><p><code>Null</code>类型只有一个值，就是<strong>null</strong>。</p><p>null是一个关键字</p><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a><strong>Boolean</strong> 类型</h3><p><code>Boolean</code>类型表示具有两个值的逻辑实体，分别为<strong>true</strong>和<strong>false</strong>。</p><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a><strong>String</strong> 类型</h3><p>一个字符串是由0个或多个字符组成，若理解字符串，先理解字符是什么？首先，计算机并不认识每个字符的图形符号，计算机只能存储二进制数字。那么若想存储图形符号怎么办呢？这就不得不提<strong>字符集</strong>了。</p><p>既然计算机只能存储二进制数字，那么就用特定的数字表示特定的图形符号。于是乎，数字与图形符号的映射关系诞生了，这个东西就叫<strong>字符集</strong>。其中与每个图形符号对应的数字也叫<strong>码点(Code Point)**（起个高大上的名字显得专业）。图形符号就是</strong>字符(Character)<strong>。这会儿我们应该知道了，计算机实际存储的并不是一个个的字符，而是这一个个字符对应的</strong>码点<strong>。由于计算机存储的基本单位是字节（8bit），而</strong>码点<strong>的大小有可能超出一个字节，为了解决这个问题，</strong>编码方式(Encoding)<strong>出现了。</strong>编码方式**规定了计算机如何存储码点。</p><p><a href="">了解更多字符集相关的内容</a></p><p>ECMAScript采用的是UTF16编码，即把每个UTF16单元当作一个字符来处理，我们用来操作字符串的一些方法如charAt、charCodeAt、length等都是针对UTF16编码实现的，在处理BMP字符时，是正常的，但是在处理非BMP字符时就会出现问题。不过好在ES6对应的可以处理非BMP字符的方法，如fromCodePoint、codePointAt。</p><p>一个字符串的最大长度为2<sup>52</sup>-1，注意这里的最大长度并不是所谓的字符数，实际上是受字符串的编码长度影响的，这是由于不同的编码方式，存储一个字符所占的内存空间不同。</p><p>字符串可以看做是由字符构成的有序序列集合，每个字符都在这个序列中占据一个位置。这些位置用非负整数作索引，从索引0开始，以自然数排序直到字符串结束位置，例如：长度为5的字符串，第一个字符索引就是0，第二个是1，以此类推直到最后一位的索引是4。</p><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p><strong>Number</strong>类型在JavaScript中有18437736874454810627(即 2<sup>64</sup>-2<sup>53</sup>+3)个值。基本复合IEEE754-2019规定的64位双精度浮点数的规则。除了IEEE标准的9,007,199,254,740,990(即2<sup>53</sup> - 2)在ECMAScript中表示为单个特殊的<strong>NaN</strong>值之外。</p><p>除了<strong>NaN</strong>外还有两个特殊的值，分别是**+Infinity(正无穷)大<strong>和</strong>-Infinity(负无穷大)**</p><p>其他的18,437,736,874,454,810,624(即2<sup>64</sup> - 2<sup>53</sup>)个值称为有限数。一半是正数，一半是负数;对于每一个有限的正数值，都有一个相应的具有相同大小的负值。</p><p>根据双精度浮点数的定义，Number类型中有效的整数范围是-0x1fffffffffffff 至 0x1fffffffffffff，所以Number无法精确表示此范围外的整数。</p><p>同样的根据浮点数的定义，非整数的Number类型无法用==或===来比较。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">==</span> <span class="token number">0.3</span><span class="token punctuation">)</span> <span class="token comment">//false</span></code></pre><p>这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。正确的比较方法是使用JavaScript提供的最小精度值：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">-</span> <span class="token number">0.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span></code></pre><p>检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了。</p><p>所有绝对值不大于2<sup>53</sup>的正整数和负整数都可以用Number类型来表示。而且整数0也有+0(可以省略+号)和-0的表示方式。他们在加减法类的运算中没有区别，但是在除法中需要注意，当除数为-0时得到的是**-Infinity<strong>，当除数是+0时得到的是</strong>+Infinity**。</p><p><a href="">双精度浮点类型的表示原理</a></p><p><strong>注意：</strong></p><p><strong>Number</strong>类型的表示方式分为以下四种：</p><ul><li><p><strong>十六进制(HexIntegerLiteral)</strong></p><pre class="language-none"><code class="language-none">0xFF</code></pre></li><li><p><strong>十进制(DecimalLiteral)</strong></p><pre class="language-none"><code class="language-none">11.11..11e2</code></pre></li><li><p><strong>八进制(OctalIntegerLiteral)</strong></p><pre class="language-none"><code class="language-none">0o17</code></pre></li><li><p><strong>二进制(BinaryIntegerLiteral)</strong></p><pre class="language-none"><code class="language-none">0b101</code></pre></li></ul><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p><strong>BigInt</strong>类型是最新数据类型，目前处于第三阶段提案，还未纳入标准规范中，因此这里不就不谈论了，想了解更多BigInt的信息，可以参照：</p><ul><li><a href="https://segmentfault.com/a/1190000019912017">前端小智</a></li><li><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types-bigint-type">标准规范</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
